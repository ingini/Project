import json
import boto3
import pytz
import signal
import traceback
from datetime import datetime
from timeout import LambdaTimeoutException

sqs_url = 'https://sqs.ap-northeast-2.amazonaws.com/284145144652/AWS-Daily-Billing-Report'
erb_arn = 'arn:aws:sns:ap-northeast-2:284145144652:hm_erb_send_email'

messages = []

def timeout_handler(_signal, _frame):
    raise LambdaTimeoutException('Time limit exceeded')

signal.signal(signal.SIGALRM, timeout_handler)

sqs = boto3.client('sqs')
sns = boto3.client('sns')

def lambda_handler(event, context):
    
    try:
        signal.alarm(int(context.get_remaining_time_in_millis() / 1000) - 1)
    
        while True:
            response = sqs.receive_message(
                QueueUrl=sqs_url,
                AttributeNames=[
                    'SentTimestamp'
                ],
                MaxNumberOfMessages=1,
                MessageAttributeNames=[
                    'All'
                ],
                VisibilityTimeout=0,
                WaitTimeSeconds=0
            )
        
            if 'Messages' in response:
                print('start processing error message')
                message = response['Messages'][0]
                receipt_handle = message['ReceiptHandle']
                response = sqs.delete_message(QueueUrl=sqs_url, ReceiptHandle=receipt_handle)
                body = message['Body'].split(',')
                print(message)
                print(body)
                
                report_name = body[0]
                reporting_function = body[1]
                report_content = body[2]
                    
                print(message['Attributes']['SentTimestamp'])
                print(message)
                report_time = datetime.fromtimestamp(int(int(message['Attributes']['SentTimestamp'])/1000) ).astimezone(pytz.timezone('Asia/Seoul'))
                report = 'report_name: {}\nreporting_function: {}\nreport_content: {}\nreport_time: {}\n'.format(report_name, reporting_function, report_content, report_time)
                messages.append(report)
                print('end processing error message')
                
                
            else:                        
                print('no more messsage to consume')
                break
        
        print(json.dumps(messages))
        
        if len(messages) > 0:
            message_send = '===================================start=======================================\n'
            for message in messages:
                message_send = message_send + '_______________________________________________________________________________\n'
                message_send = message_send + message
                message_send = message_send + '_______________________________________________________________________________\n'
            message_send = message_send + '\n====================================end========================================\n'
            
            response = sns.publish(
                TopicArn=erb_arn,
                Message=message_send,
                Subject='AWS Daily Billing Report'
            )     
            
        else:
            print('no messsage to report')
            
            
        signal.alarm(0)
            
        return {
            'statusCode': 200,
            'body': json.dumps('success')
        }
    except LambdaTimeoutException as e:
        msg = sqs.send_message(QueueUrl="https://sqs.ap-northeast-2.amazonaws.com/284145144652/Lambda-Daily-Error-Report", MessageBody="Timeout,{},{}".format(context.function_name, context.aws_request_id))
        return {'statusCode': 400, 'body': str(e)}
    except Exception as e:
        traceback.print_exc()
        msg = sqs.send_message(QueueUrl="https://sqs.ap-northeast-2.amazonaws.com/284145144652/Lambda-Daily-Error-Report", MessageBody="Error,{},{},{}".format(context.function_name, context.aws_request_id, traceback.format_exc()))
        return {'statusCode': 400, 'body': str(e)}  
        


if __name__ == '__main__':
    lambda_handler(None, None)